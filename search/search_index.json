{"config":{"indexing":"full","lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"Architecture for the ComputePods MajorDomo web based User Interface","title":"Architecture for the ComputePods MajorDomo web based User Interface"},{"location":"#architecture-for-the-computepods-majordomo-web-based-user-interface","text":"","title":"Architecture for the ComputePods MajorDomo web based User Interface"},{"location":"mithril/","text":"Using Mithril We use Mithril to provide our browser based Model View Controller. Mithril provides tools to work asynchronously with the server using promises , typically provided by the Mithril request interface . Mithril objects, called components , are simply Plain Old JavaScript Objects which have a view method. Any Mithril component is itself a model which can hold its own state . Any Mithril component integrates with the browser's underlying view by implementing a view method. Any Mithril component integrates with the browser's underlying controller by adding any of the standard GlobalEventHandlers as an attribute. Our use of Mithril Any Mithril component which is related in some way to information on the server, will consist of a mixin of the following two interfaces: A Mithril View mixin, which uses a Mithril view method to display the component to the user. A Mithril Connector mixin, which uses a Mithril request to obtain the component data for a particular target URL on the server, via a HTTP request to the MajorDomo server's REST interface. These two mixin parts of a Mithril component will \"communicate\" using a common data property. The pairing itself will be determined by the unique prefix of each URL. This means that different server URL mount points must have unique prefixes. We will implement this mixin pattern using the Object.assign() method.","title":"Using Mithril"},{"location":"mithril/#using-mithril","text":"We use Mithril to provide our browser based Model View Controller. Mithril provides tools to work asynchronously with the server using promises , typically provided by the Mithril request interface . Mithril objects, called components , are simply Plain Old JavaScript Objects which have a view method. Any Mithril component is itself a model which can hold its own state . Any Mithril component integrates with the browser's underlying view by implementing a view method. Any Mithril component integrates with the browser's underlying controller by adding any of the standard GlobalEventHandlers as an attribute.","title":"Using Mithril"},{"location":"mithril/#our-use-of-mithril","text":"Any Mithril component which is related in some way to information on the server, will consist of a mixin of the following two interfaces: A Mithril View mixin, which uses a Mithril view method to display the component to the user. A Mithril Connector mixin, which uses a Mithril request to obtain the component data for a particular target URL on the server, via a HTTP request to the MajorDomo server's REST interface. These two mixin parts of a Mithril component will \"communicate\" using a common data property. The pairing itself will be determined by the unique prefix of each URL. This means that different server URL mount points must have unique prefixes. We will implement this mixin pattern using the Object.assign() method.","title":"Our use of Mithril"},{"location":"packaging/","text":"Packaging the web interface Using Parcel to bundle our web interface We use parcel to bundle our web interface.","title":"Packaging the web interface"},{"location":"packaging/#packaging-the-web-interface","text":"","title":"Packaging the web interface"},{"location":"packaging/#using-parcel-to-bundle-our-web-interface","text":"We use parcel to bundle our web interface.","title":"Using Parcel to bundle our web interface"},{"location":"testing/","text":"Testing the web interface In order to develop, unit, integration and end-to-end tests of our interface, we will use a mixture of Our own Mithril Component Viewer , AVA , Mithril-Query Mock Service Workers Our Mithril Component Viewer (mcv) provides a component focused collection of Mithril \"pages\", one for each component example. Each such example is \"constructed\" in a CommonJS module located beside the code for which it provides an example, in files named <aName>.mcv.cjs . These Mithril Component Views (mcv) are crudely \"compiled\" into the mcv Mithril application by the createMCVapp node script located in the mcv directory . Our tests, like our Mithril component examples, will be located beside the code it tests in files named <aName>.tests.js . Development Will be developed using MCV examples working in a top down fashion. That is we begin by developing stories for \"complete\" pages and then refactor common components into their own examples. (The opposite of a component driven interface , though we will use these ideas). Lightweight documentation will be developed using pure Markdown Readme.md files in each page/component directory. To work with the MCV examples we use the npm run dev command which runs, in parallel, the createMCVapp and the Parcel serve command on the resulting app. To work with the pure Markdown \"stories\" we use the mdstart command (installed using a global installation of the md-fileserver live reloading Markdown file server). Unit and integration testing Will be tested using AVA and Mock Service Workers. End-to-end testing To be determined. What to test? Generally we are only interested in making sure the functional structure of the interface exists and behaves as documented. We are not overly interested in making sure the surface visualisation is consistent. This would be nice to have, but we should not expend effort making sure it is tested in much detail if at all.","title":"Testing the web interface"},{"location":"testing/#testing-the-web-interface","text":"In order to develop, unit, integration and end-to-end tests of our interface, we will use a mixture of Our own Mithril Component Viewer , AVA , Mithril-Query Mock Service Workers Our Mithril Component Viewer (mcv) provides a component focused collection of Mithril \"pages\", one for each component example. Each such example is \"constructed\" in a CommonJS module located beside the code for which it provides an example, in files named <aName>.mcv.cjs . These Mithril Component Views (mcv) are crudely \"compiled\" into the mcv Mithril application by the createMCVapp node script located in the mcv directory . Our tests, like our Mithril component examples, will be located beside the code it tests in files named <aName>.tests.js .","title":"Testing the web interface"},{"location":"testing/#development","text":"Will be developed using MCV examples working in a top down fashion. That is we begin by developing stories for \"complete\" pages and then refactor common components into their own examples. (The opposite of a component driven interface , though we will use these ideas). Lightweight documentation will be developed using pure Markdown Readme.md files in each page/component directory. To work with the MCV examples we use the npm run dev command which runs, in parallel, the createMCVapp and the Parcel serve command on the resulting app. To work with the pure Markdown \"stories\" we use the mdstart command (installed using a global installation of the md-fileserver live reloading Markdown file server).","title":"Development"},{"location":"testing/#unit-and-integration-testing","text":"Will be tested using AVA and Mock Service Workers.","title":"Unit and integration testing"},{"location":"testing/#end-to-end-testing","text":"To be determined.","title":"End-to-end testing"},{"location":"testing/#what-to-test","text":"Generally we are only interested in making sure the functional structure of the interface exists and behaves as documented. We are not overly interested in making sure the surface visualisation is consistent. This would be nice to have, but we should not expend effort making sure it is tested in much detail if at all.","title":"What to test?"},{"location":"ui/","text":"User interface (webpages) Goal We need a simple and dynamic user interface with which to control and monitor the ComputePods (ongoing) behaviour. This interface should be run-able inside modern browsers (such as FireFox and Chromium). Nice to have We will need a hierarchical view of project files, as well as tasks and associated logfiles. Since the ComputePods will build up an intimate knowledge of the artefacts it builds, down to locations of cross-references, figures, chapters, sections, etc for ConTeXt, as well as variable and function definitions for ANSI-C and JoyLoL, it will eventually make sense to expose this knowledge by being able to \"jump\" to the textual source underlying each (generalised) reference. This suggests the use of an embedded \"code\" editor (CodeJar), as well as syntax highlighting (Prism). The ability to have multiple panes open on tasks side by side, suggests the use of a split panel JavaScript tool (SplitJS). The ability to visualise the graphical networks of, for example, (potentially cyclic) build dependency networks, or concept cross-reference networks, suggests the use of D3 (and SVG). Word clouds, driven by D3, might make nice entries into the concept cross-reference networks (clouds). UI standards Our UI itself is based upon \"standard\" JavaScript run in the client's browser. JavaScript W3C DOM Mozilla DOM UI packages Our objective in choosing the UI packages is to keep things as \"simple\" and \"independently\" \"mixable\" as possible. At this point it is hard to see how we might want to mix and match tools to create a useful user experience, but certainly keeping things as modular as possible will allow for future inspiration. Mithril Bulma D3 D3-mitch-tree SplitJS CodeJar Prism Note we will probably eventually need to create our own language for JoyLoL. So we want to use Prism now to allow this in the future. We will use the Webpack, babel and babel-plugin-prismjs development tools (below) to pragmatically produce our own minified prism files. FontAwesome(free) A collection of fonts and icons . UI development tools Mithril Component Viewer AVA Sass Parcel Babel (used by Parcel) Mock Service Workers is used to develop and test the client-UI separate from the server. Note : At the moment, Mock Service Workers does not seem to work in Firefox but does work in Chrome. AJV might be used to test/verify the rest interface between the client and the server.","title":"User interface (webpages)"},{"location":"ui/#user-interface-webpages","text":"","title":"User interface (webpages)"},{"location":"ui/#goal","text":"We need a simple and dynamic user interface with which to control and monitor the ComputePods (ongoing) behaviour. This interface should be run-able inside modern browsers (such as FireFox and Chromium).","title":"Goal"},{"location":"ui/#nice-to-have","text":"We will need a hierarchical view of project files, as well as tasks and associated logfiles. Since the ComputePods will build up an intimate knowledge of the artefacts it builds, down to locations of cross-references, figures, chapters, sections, etc for ConTeXt, as well as variable and function definitions for ANSI-C and JoyLoL, it will eventually make sense to expose this knowledge by being able to \"jump\" to the textual source underlying each (generalised) reference. This suggests the use of an embedded \"code\" editor (CodeJar), as well as syntax highlighting (Prism). The ability to have multiple panes open on tasks side by side, suggests the use of a split panel JavaScript tool (SplitJS). The ability to visualise the graphical networks of, for example, (potentially cyclic) build dependency networks, or concept cross-reference networks, suggests the use of D3 (and SVG). Word clouds, driven by D3, might make nice entries into the concept cross-reference networks (clouds).","title":"Nice to have"},{"location":"ui/#ui-standards","text":"Our UI itself is based upon \"standard\" JavaScript run in the client's browser. JavaScript W3C DOM Mozilla DOM","title":"UI standards"},{"location":"ui/#ui-packages","text":"Our objective in choosing the UI packages is to keep things as \"simple\" and \"independently\" \"mixable\" as possible. At this point it is hard to see how we might want to mix and match tools to create a useful user experience, but certainly keeping things as modular as possible will allow for future inspiration. Mithril Bulma D3 D3-mitch-tree SplitJS CodeJar Prism Note we will probably eventually need to create our own language for JoyLoL. So we want to use Prism now to allow this in the future. We will use the Webpack, babel and babel-plugin-prismjs development tools (below) to pragmatically produce our own minified prism files. FontAwesome(free) A collection of fonts and icons .","title":"UI packages"},{"location":"ui/#ui-development-tools","text":"Mithril Component Viewer AVA Sass Parcel Babel (used by Parcel) Mock Service Workers is used to develop and test the client-UI separate from the server. Note : At the moment, Mock Service Workers does not seem to work in Firefox but does work in Chrome. AJV might be used to test/verify the rest interface between the client and the server.","title":"UI development tools"}]}